
// Generated by Qodo Gen

import org.junit.Test;
import static org.junit.Assert.*;

public class Mergesort(int[],Int)Test {


    // Sort array with random positive integers in ascending order
    @Test
    public void test_sort_random_positive_integers() {
        int[] input = {5, 2, 8, 1, 9, 3};
        int[] expected = {1, 2, 3, 5, 8, 9};
    
        int[] result = mergesort(input, input.length);
    
        assertArrayEquals(expected, result);
    }

    // Sort empty array
    @Test
    public void test_sort_empty_array() {
        int[] input = {};
        int[] expected = {};
    
        int[] result = mergesort(input, input.length);
    
        assertArrayEquals(expected, result);
    }

    // Verify that each element at index i is less than or equal to element at index i+1
    @Test
    public void test_sorted_order() {
        int[] input = {7, 4, 5, 2, 6, 1};
        int[] result = mergesort(input, input.length);

        for (int i = 0; i < result.length - 1; i++) {
            assertTrue(result[i] <= result[i + 1]);
        }
    }

    // Sort array with even number of elements
    @Test
    public void test_sort_even_number_of_elements() {
        int[] input = {4, 1, 3, 2};
        int[] expected = {1, 2, 3, 4};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Sort array with odd number of elements
    @Test
    public void test_sort_odd_number_of_elements() {
        int[] input = {7, 3, 5, 1, 9};
        int[] expected = {1, 3, 5, 7, 9};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Sort already sorted array
    @Test
    public void test_sort_already_sorted_array() {
        int[] input = {1, 2, 3, 4, 5, 6};
        int[] expected = {1, 2, 3, 4, 5, 6};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Sort array with all elements being equal
    @Test
    public void test_sort_array_with_equal_elements() {
        int[] input = {7, 7, 7, 7, 7};
        int[] expected = {7, 7, 7, 7, 7};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Sort array with single element
    @Test
    public void test_sort_single_element_array() {
        int[] input = {42};
        int[] expected = {42};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Sort array with Integer.MAX_VALUE and Integer.MIN_VALUE
    @Test
    public void test_sort_with_max_and_min_values() {
        int[] input = {Integer.MAX_VALUE, Integer.MIN_VALUE, 0, -1, 1};
        int[] expected = {Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Sort array with length 2 (minimum length for actual sorting)
    @Test
    public void test_sort_array_length_two() {
        int[] input = {2, 1};
        int[] expected = {1, 2};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Sort array with negative numbers
    @Test
    public void test_sort_array_with_negative_numbers() {
        int[] input = {-3, -1, -7, -4, -5, -2};
        int[] expected = {-7, -5, -4, -3, -2, -1};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Sort array with very large number of elements
    @Test
    public void test_sort_large_array() {
        int[] input = new int[1000000];
        for (int i = 0; i < input.length; i++) {
            input[i] = input.length - i;
        }
        int[] expected = new int[1000000];
        for (int i = 0; i < expected.length; i++) {
            expected[i] = i + 1;
        }

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Verify correct handling of deep recursion levels
    @Test
    public void test_deep_recursion_handling() {
        int[] input = new int[10000];
        for (int i = 0; i < input.length; i++) {
            input[i] = input.length - i;
        }
        int[] expected = new int[10000];
        for (int i = 0; i < expected.length; i++) {
            expected[i] = i + 1;
        }

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Check if array copying maintains efficiency
    @Test
    public void test_large_array_sorting_efficiency() {
        int size = 1000000;
        int[] input = new int[size];
        for (int i = 0; i < size; i++) {
            input[i] = size - i;
        }
        int[] expected = new int[size];
        for (int i = 0; i < size; i++) {
            expected[i] = i + 1;
        }

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Ensure proper memory management during recursive calls
    @Test
    public void test_memory_management_large_array() {
        int[] input = new int[1000000];
        for (int i = 0; i < input.length; i++) {
            input[i] = input.length - i;
        }
        int[] result = mergesort(input, input.length);
        for (int i = 0; i < result.length - 1; i++) {
            assertTrue(result[i] <= result[i + 1]);
        }
    }

    // Sort array containing zeros
    @Test
    public void test_sort_array_with_zeros() {
        int[] input = {0, 5, 0, 3, 0, 2};
        int[] expected = {0, 0, 0, 2, 3, 5};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Sort array with reverse sorted elements
    @Test
    public void test_sort_reverse_sorted_array() {
        int[] input = {9, 8, 7, 6, 5, 4, 3, 2, 1};
        int[] expected = {1, 2, 3, 4, 5, 6, 7, 8, 9};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Handle array modifications during recursive calls
    @Test
    public void test_handle_array_modifications_during_recursive_calls() {
        int[] input = {4, 1, 3, 9, 7, 2};
        int[] expected = {1, 2, 3, 4, 7, 9};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Verify array copies prevent interference between recursive calls
    @Test
    public void test_array_copies_prevent_interference() {
        int[] input = {4, 1, 3, 9, 7, 2, 6, 5};
        int[] expected = {1, 2, 3, 4, 5, 6, 7, 9};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Check if modifications in subarrays are properly isolated
    @Test
    public void test_modifications_in_subarrays_isolated() {
        int[] input = {4, 1, 3, 9, 7, 2};
        int[] expected = {1, 2, 3, 4, 7, 9};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }

    // Ensure final merge combines modified subarrays correctly
    @Test
    public void test_final_merge_combines_subarrays_correctly() {
        int[] input = {4, 1, 3, 9, 7, 2, 6, 5};
        int[] expected = {1, 2, 3, 4, 5, 6, 7, 9};

        int[] result = mergesort(input, input.length);

        assertArrayEquals(expected, result);
    }
}